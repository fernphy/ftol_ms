---
title: "An Open and Continuously Updated Fern Tree of Life"
mainfont: Roboto-Regular.ttf
fontsize: 11pt
mainfontoptions: 
  - BoldFont=Roboto-Bold.ttf
  - ItalicFont=Roboto-Italic.ttf
  - BoldItalicFont=Roboto-BoldItalic.ttf
output: 
  bookdown::pdf_document2:
    citation_package: default
    toc: no
    number_sections: yes
    fig_caption: yes
    keep_tex: no
    latex_engine: xelatex
    pandoc_args: [ "--csl", "frontiers.csl"]
  bookdown::word_document2:
    pandoc_args: [ "--csl", "frontiers.csl"]
    toc: no
    number_sections: no
    reference_docx: Frontiers_Template.docx
header-includes: 
  - \usepackage{float} # keep figures from floating away
  - \makeatletter\renewcommand*{\fps@figure}{H}\makeatother # keep figures from floating away
  - \usepackage{fancyhdr} # enable header
  - \cfoot{\thepage} # footer
editor_options: 
  chunk_output_type: console
params:
  doc_type: manual
---

---
bibliography: 
- `r here::here("ms/references.yaml")`
- `r here::here("ms/references_other.yaml")`
- `r here::here("ms/references_other.bib")`
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = FALSE, warning = FALSE, message = FALSE,
  results = 'hide', cache = FALSE)
# Load packages
source(here::here("R/ms_packages.R"))
```

```{r formatters-load}
# Load formatting functions defined in functions.R
knitr::read_chunk(
  here::here("R/functions.R"),
  labels = "formatters",
  from = "formatters start",
  to = "formatters end"
)
```

```{r, formatters}
```

```{r load-functions, eval = params$doc_type == "manual"}
# Load functions (only if running interactively)
source(here::here("R/functions.R"))
``` 

```{r load-targets}
# Targets from FTOL workflow

# Specify path to FTOL cache
ftol_cache <- here::here("ftol_cache")

accs_exclude <- read_from_cache("accs_exclude", ftol_cache)
con_fossil_calibration_tips <- read_from_cache("con_fossil_calibration_tips", ftol_cache) # nolint
fern_sanger_seqs_raw <- read_from_cache("fern_sanger_seqs_raw", ftol_cache)
fossil_ferns_raw <- read_from_cache("fossil_ferns_raw", ftol_cache)
plastome_alignment <- read_from_cache("plastome_alignment", ftol_cache)
plastome_alignment_tbl <- read_from_cache("plastome_alignment_tbl", ftol_cache)
plastome_metadata_raw_all <- read_from_cache("plastome_metadata_raw_all", ftol_cache) # nolint
plastome_metadata_renamed <- read_from_cache("plastome_metadata_renamed", ftol_cache) # nolint
plastome_metadata_renamed <- read_from_cache("plastome_metadata_renamed", ftol_cache) # nolint
plastome_seqs_combined_filtered <- read_from_cache("plastome_seqs_combined_filtered", ftol_cache) # nolint
plastome_tree_rooted <- read_from_cache("plastome_tree_rooted", ftol_cache)
pteridocat <- read_from_cache("pteridocat", ftol_cache)
raw_fasta_all <- read_from_cache("raw_fasta_all", ftol_cache)
sanger_accessions_selection <- read_from_cache("sanger_accessions_selection", ftol_cache) # nolint
sanger_alignment <- read_from_cache("sanger_alignment", ftol_cache)
sanger_alignment_tbl <- read_from_cache("sanger_alignment_tbl", ftol_cache)
sanger_con_tree_rooted <- read_from_cache("sanger_con_tree_rooted", ftol_cache)
sanger_seqs_combined_filtered <- read_from_cache("sanger_seqs_combined_filtered", ftol_cache) # nolint
sanger_seqs_rogues_removed <- read_from_cache("sanger_seqs_rogues_removed", ftol_cache) # nolint
ts_fossil_calibration_tips <- read_from_cache("ts_fossil_calibration_tips", ftol_cache) # nolint
renv_pkg_versions <- read_from_cache("renv_pkg_versions", ftol_cache)
sw_versions <- read_from_cache("sw_versions", ftol_cache)
ftol_r_ver <- read_from_cache("ftol_r_ver", ftol_cache)
pkg_versions <- bind_rows(renv_pkg_versions, sw_versions)

# Targets from MS workflow
tar_load(
  c(
    accepted_species,
    bb_coverage_by_rank,
    bb_total_coverage,
    coverage_by_rank,
    crown_ages,
    family_stem_ages,
    fern_monophy_summ_tbl,
    fern_nonmono_gen,
    ftol_ts_comp_mod,
    gb_species_by_year,
    other_dates,
    plastome_iqtree_log,
    ref_files,
    sanger_iqtree_log_2000,
    sanger_sampling,
    total_coverage,
    treepl_cv_results,
    ppgi_taxonomy,
    sanger_tree_dated
  ),
  store = here::here("_targets")
)
```

```{r abstract-stats}
# Make tibble of outgroup species
og_species <- 
  plastome_metadata_renamed %>%
  select(species, outgroup) %>%
  filter(outgroup == TRUE)

# Count number of fern species in Sanger data
n_sanger_ferns <-
  sanger_sampling %>% 
  filter(outgroup == FALSE) %>%
  n_distinct(.$species)

# Count number of calibration points
n_calibrations_ferns <-
  con_fossil_calibration_tips %>%
  assert(is_uniq, node_calibrated) %>%
  filter(!affinities %in% c("Tracheophytes", "Euphyllophytes")) %>%
  pull(node_calibrated) %>%
  n_distinct() %>%
  number()

n_calibrations_total <-
  con_fossil_calibration_tips %>%
  assert(is_uniq, node_calibrated) %>%
  pull(node_calibrated) %>%
  n_distinct() %>%
  number()
```

<!-- Set left justification -->
\raggedright

<!-- Do not indent -->
\setlength{\parindent}{0ex}

**Joel H. Nitta^1,9^, Eric Schuettpelz^2^, Santiago Ramírez-Barahona^3^, and Wataru Iwasaki^1,4,5,6,7,8^**

^1^Department of Biological Sciences, Graduate School of Science, The University of Tokyo, Tokyo, Japan

^2^Department of Botany, National Museum of Natural History, Smithsonian Institution, Washington, District of Columbia, United States

^3^Departamento de Botánica, Instituto de Biología, Universidad Nacional Autónoma de México, Mexico City, Mexico

^4^Department of Integrated Biosciences, Graduate School of Frontier Sciences, The University of Tokyo, Chiba, Japan

^5^Department of Computational Biology and Medical Sciences, Graduate School of Frontier Sciences, The University of Tokyo, Chiba, Japan

^6^Atmosphere and Ocean Research Institute, The University of Tokyo, Chiba, Japan

^7^Institute for Quantitative Biosciences, The University of Tokyo, Tokyo, Japan

^8^Collaborative Research Institute for Innovative Microbiology, The University of Tokyo, Tokyo, Japan

^9^Current affiliation: Department of Integrated Biosciences, Graduate School of Frontier Sciences, The University of Tokyo, Chiba, Japan

**\*Correspondence:**    
Joel H. Nitta  
joelnitta@gmail.com

Keywords: fern~1~, phylogeney~2~, plastome~3~, PPGI~4~, pteridophyte~5~, *rbcL*~6~.

# Abstract

Ferns, with about `r number(12000)` species, are the second most diverse lineage of vascular plants after angiosperms.
They have been the subject of numerous molecular phylogenetic studies, resulting in the publication of trees for every major clade and DNA sequences from nearly half of all species.
Global fern phylogenies have been published periodically, but as molecular systematics research continues at a rapid pace, these become quickly outdated.

Here, we develop a mostly automated, reproducible, open pipeline to generate a continuously updated fern tree of life (FTOL) from DNA sequence data available in GenBank.
Our tailored sampling strategy combines whole plastomes (few taxa, many loci) with commonly sequenced plastid regions (many taxa, few loci) to obtain a global, species-level fern phylogeny with high resolution along the backbone and maximal sampling across the tips.
We use a curated reference taxonomy to resolve synonyms in general compliance with the community-driven Pteridophyte Phylogeny Group I classification.

The current FTOL includes `r comma(n_sanger_ferns)` species, an increase of `r ca` 40% relative to the most recently published global fern phylogeny.
Using an updated and expanded list of `r n_calibrations_ferns` fern fossil constraints, we find estimated ages for most families and deeper clades to be considerably older than earlier studies.

FTOL and its accompanying datasets, including the fossil list and taxonomic database, will be updated on a regular basis and are available via a web portal (https://fernphy.github.io) and R packages, enabling immediate access to the most up-to-date, comprehensively sampled fern phylogeny.
FTOL will be useful for anyone studying this important group of plants over a wide range of taxonomic scales, from smaller clades to the entire tree.
We anticipate FTOL will be particularly relevant for macroecological studies at regional to global scales and will inform future taxonomic systems with the most recent hypothesis of fern phylogeny.

# Introduction

Ferns (`r ca` `r number(12000)` species) are the second most diverse lineage of vascular plants after angiosperms (`r ca` `r number(300000)` species) and are a useful study system for understanding processes of biogeography [`r eg`, @Tryon1986; @Kato1993], community ecology [`r eg`, @Hennequin2014; @Lehtonen2015], and speciation [`r eg`, @Kao2020].
Key to any investigation of evolutionary history in this group is a well-sampled phylogeny.
Fortunately, ferns have received relatively intense focus from molecular systematists, which has resulted in the publication of trees for all major clades and DNA sequence data from nearly half of all currently recognized fern species.
Thus, there is both a pressing need and sufficient sampling for a globally sampled fern phylogeny.

Past efforts to construct such a global phylogeny have steadily expanded their sampling, at first by mostly generating new sequences, then later by mining GenBank [@Pryer2004a; @Lehtonen2011; @Schuettpelz2007; @Testo2016a].
Indeed, the growth of plastid fern accessions in GenBank shows no sign of slowing since the most recent global fern phylogeny [@Testo2016a\; `r figure("genbank")`].
There is a need therefore, not only for a revised global fern phylogeny, but also one that is continuously updated to keep pace with the rapid accumulation of molecular data going forward.
Such an effort would eliminate the need for researchers to "reinvent the wheel" each time the need for a globally sampled fern phylogeny arises.

Multiple frameworks have been put forth to automatically or semi-automatically generate trees for any particular part of the tree of life [@Antonelli2016], all plants [@Eiserhardt2018], or even the entire tree of life at once [@Hinchliff2015], which would of course subsume a global fern phylogeny.
While such approaches are well-suited to some studies, they cannot be expected to produce an optimal fern phylogeny due to the use of "one-size-fits-all" methods to accommodate such a wide phylogenetic breadth.
By focusing methods and datasets specifically on ferns, it should be possible to generate a higher quality end-product (tree) that can then be used "as-is" by biologists studying these organisms.
Furthermore, there is much to be gained from integrating a carefully designed global fern phylogeny with the fern systematics community that would not be as easily accomplished with a "tree of all life" or "tree of all plants".

Recently, a taxonomy of ferns and lycophytes was established at the genus level and higher using an inclusive, community-driven approach  [@PteridophytePhylogenyGroupI2016\; hereafter "PPG I"].
PPG I has been widely accepted and used, but there were problematic (non-monophyletic) genera included at the time of publication, and many taxonomic changes have been (and will continue to be) proposed since [`r eg`, @Almeida2017; @Shang2018; @Zhang2020].
The next iteration of the PPG classification (`r ie`, PPG II) will ideally be an online, open resource that can be updated as necessary.
We envision an open, continuously updated global fern phylogeny that could be directly integrated with PPG II such that taxonomic decisions can be made based on community consensus and the most recently available data.

Here, we leverage taxonomic knowledge to design a custom, fully reproducible, mostly automated pipeline to generate a maximally sampled global fern tree of life (FTOL; `r figure("workflow")`).
We plan to run the pipeline on a regular basis and make the results freely available online through a web portal (https://fernphy.github.io) and R package [@ftol2022c].
This will enable anybody interested in the biology of ferns to have access to the most current hypothesis of fern phylogeny, and an associated time-tree dated using a curated list of fern fossils.
We anticipate FTOL will have multiple impacts on the field of fern systematics and evolution: 1) it will always provide the most up-to-date snapshot of our collective understanding of fern relationships; 2) it will allow for continuous assessment of taxonomy, and indicate those parts of the tree that are in need of taxonomic revision; and 3) it will be an important source of data for phylogenetic comparative and macroevolutionary studies of ferns.

# Materials and Methods

## Locus selection

The plastid genome has been the most widely sequenced genomic compartment in ferns by far (`r figure("genbank")`), so we used plastid loci to build our tree.
Our sampling includes two major categories of sequence data: 1) seven loci (*atpA*, *atpB*, *matK*, *rbcL*, *rps4*, *trnL*--*trnF*, and *rps4*--*trnS*) that have been frequently used in molecular analyses of ferns and are typically obtained by PCR and Sanger sequencing ("Sanger loci"); and 2) a much larger set of single-copy loci typically obtained from next-generation sequencing of the plastome ("plastome loci").
Here, the *trnL*--*trnF* locus includes the *trnL* intron, the `r "3'"` *trnL* exon, and the *trnL*--*trnF* intergenic spacer; the *rps4*--*trnS* locus includes only the *rps4*--*trnS* intergenic spacer.
The set of plastome loci is based on the list of 83 protein-coding genes of @Wei2017a, which was filtered to only genes that show no evidence of duplication (77 genes, including *atpA*, *atpB*, *matK*, *rbcL*, and *rps4*) and then combined with the *trnL*--*trnF* and *rps4*--*trnS* loci (79 loci total).
Here, "locus" refers to an individual gene, intergenic spacer, or a unit comprised of these in the case of *trnL*--*trnF*.

## Dataset construction

The "plants" division of GenBank release 249 (cutoff date 2022-04-15) was downloaded from the NCBI FTP server (https://ftp.ncbi.nlm.nih.gov/genbank/).
A local database was then created from these data including only ferns and outgroup taxa (select seed plants, lycophytes, bryophytes, and algae) using the restez R package v`r pkg_ver("restez", pkg_versions)` [@Bennett2018a].
GenBank accession numbers corresponding to sequences potentially matching each target locus were obtained by querying GenBank with terms including the locus name (`r eg`, "rbcL"), "Polypodiopsida[ORGN]", and a date cutoff matching the current GenBank release.
Environmental DNA samples and accessions with names including the terms "aff." or "cf." or hybrid formulas were excluded (no attempt was made to exclude hybrid taxa with standard names, `r ie`, names that are not formulas).
Sequences were then obtained from the local database in FASTA format by GenBank accession number.
There is no formal definition of genomic vs. Sanger sequences in GenBank, so we used an empirical sequence length cutoff to distinguish between Sanger (≤ `r number(7000)` bp) and plastome (> `r number(7000)` bp) accessions with the "[SLEN]" term (`r s_figure("seqlen")`).

There is a lack of consensus on sequence annotation in GenBank; the same locus may be annotated using different names, or not annotated at all.
To avoid missing sequences due to differences in annotation format, we used the "Reference_Blast_Extract.py" script of superCRUNCH v`r pkg_ver("supercrunch", pkg_versions)` [@Portik2020] to extract target loci from GenBank FASTA files.
Briefly, this involves querying candidate FASTA files from GenBank with BLAST [@Altschul1997] against a reference database of full length, representative sequences [i.e., a "baited search"\; @Smith2009b; @Smith2019].
Those portions of the query that have a significant match in the reference are extracted and written to a new filtered FASTA file.

We constructed the superCRUNCH reference databases by first downloading fern sequences from GenBank, then extracting target gene sequences with a custom R script that parses the GenBank flatfile; this only works for properly annotated accessions.
We then filtered the sequences to a single representative longest sequence per genus.
Next, we aligned the filtered sequences with MAFFT v`r pkg_ver("mafft", pkg_versions)` [@Katoh2002] and removed poorly aligned regions with trimAl v`r pkg_ver("trimal", pkg_versions)` [@Capella-Gutierrez2009].
To maximize the size of the reference database for Sanger loci, we then ran "Reference_Blast_Extract.py" using these sequences as references, followed by filtering to the longest sequence per genus and alignment and cleaning as before; this retrieved additional sequences that lacked annotations in the first round.
The cleaned alignments were then used as references for superCRUNCH to obtain a maximally sampled set of fern sequences from accessions downloaded from GenBank.

## Taxonomic name resolution

This project aimed to generate a phylogeny that is consistent with PPG I, while accounting for taxonomic changes that have been made since its publication.
Species names in GenBank, which use the NCBI taxonomy [@Federhen2012; @Schoch2020], do not necessarily conform to PPG I.
Furthermore, the NCBI taxonomy is not curated specifically for ferns and includes many fern synonyms.
Therefore, we standardized all species names in the GenBank sequences (NCBI Taxonomy database dump release 2022-05-01, obtained from https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump_archive/) against a newly generated reference taxonomy.
Our reference taxonomy is based on the World Ferns database v12.8 [@Hassler2022], which conforms to PPG I (with some exceptions explained below) and is available in Darwin Core format [@DarwinCore2009] via the Catalog of Life [@COL2366].

To resolve species names, we used the taxastand R package v`r pkg_ver("taxastand", pkg_versions)` [@joel_nitta_2021_5726391], which can account for differences in formatting of taxonomic authors (`r eg`, parenthetical basionym author present or absent) and perform fuzzy matching, which is needed to account for spelling errors or variations in author names.

We manually inspected any fuzzily matched or non-matching names.
This revealed some species names in GenBank that were missing in the World Ferns database, spelling errors, and some names in the database that needed to be treated differently (`r eg`, changes in synonymy).
We thus updated and edited the initial World Ferns database using the dwctaxon R package v1.0.0 [@joel_nitta_2022_6388272], which is designed to work with taxonomic data in the Darwin Core format.
We refer to the resulting taxonomic database as "pteridocat," and have made it freely available online (https://github.com/fernphy/pteridocat) so that other researchers may standardize taxonomic names in their data to match those of FTOL [@ftol2022a].

There are differences between pteridocat and PPG I, mostly at the genus level.
In the time since PPG I was introduced, several new genera have been published.
Furthermore, multiple genera included in PPG I were known to be non-monophyletic and provisionally circumscribed [@PteridophytePhylogenyGroupI2016].
pteridocat includes newly published genera, some genera that were not recognized by PPG I, and nothogenera, which were not included in PPG I [@Liu2020a].
Differences between pteridocat and PPG I are summarized in `r s_table("genera_diff")`.

## Removal of rogue sequences using BLAST

Another potential issue with GenBank sequences is the presence of misidentified sequences, poor quality sequences, and contaminants (hereafter collectively referred to as "rogues").
We removed putative rogues from Sanger sequences as follows.
First, we constructed a BLAST library including all extracted Sanger sequences using BLAST Suite v`r pkg_ver("blast", pkg_versions)`.
Next, we conducted one BLAST search for each Sanger sequence against the library (all-by-all BLAST).
We compared the families (following PPG I) of the matching sequences to each query; in the case the top three best matches belonged to a different family than the query, that query was considered a rogue and excluded from further analysis.
For Cyatheales and Saccolomatineae, which include several closely related small families, we used the order and sub-order level, respectively, instead of family to avoid false positives.
Species belonging to monotypic families were not considered for this filtering.
While this method cannot account for rogues at finer taxonomic levels, it is an efficient approach for removing clearly erroneous sequences.
We inspected all accessions flagged this way as rogues before excluding them.
In cases where the family mismatch was due to incorrect taxonomy (`r eg`, the species name in GenBank matches the correct family but the name used in the taxonomic database does not), we updated the taxonomic database accordingly.

## Sequence concatenation and selection

A typical step in multilocus phylogenetic workflows is to concatenate loci across samples.
For phylogenetic studies aiming to include one tip per species, this is often done by concatenating the longest sequence per locus within each species, regardless of source.
However, such an approach is potentially problematic because accessions on GenBank may be misidentified and/or species may not be monophyletic.
Therefore, we concatenated accessions and selected one final set of concatenated loci per species as follows (here, we refer to "accession" to mean a single locus within a GenBank accession; GenBank accessions may contain multiple loci, but we already split those out using superCRUNCH as described above).
First, we constructed gene trees with FastTree v`r pkg_ver("fasttree", pkg_versions)` [@Price2009; @Price2010] on default settings, and classified species as monophyletic if they were monophyletic in all gene trees including multiple accessions of that species.
Then, we concatenated loci that met any of the following three conditions: 1) if a species was monophyletic, loci were concatenated by selecting the longest accession per locus within that species; 2) if all accessions originated from the same voucher specimen, loci were concatenated across accessions; 3) if all accessions for a given species originated from only one publication, loci were concatenated across accessions.
Accessions not meeting any of these conditions were not concatenated.
All calculations of sequence length excluded missing bases ("?", "N", or "-").

We selected the final set of concatenated loci for each species based on presence of *rbcL* and sequence length.
We sought to maximize representation of *rbcL* as this is historically the most sequenced locus for ferns, and maximal sampling of one locus has been shown to improve results in super-matrix phylogenies [@Talavera2021].
Our procedure for selecting accessions for each species was as follows: 1) if accessions are concatenated including *rbcL* and at least one other locus, select the set of concatenated accessions with the greatest total sequence length; 2) otherwise, if accessions include *rbcL* only, select the accession with the longest *rbcL* sequence; 3) otherwise, select the accession or set of concatenated accessions with the greatest total sequence length.
These steps were not needed for plastome data, as each plastome sequence on GenBank originates from a single voucher specimen.
For these, we selected the one specimen per species with the longest combined sequence length across all plastome loci.

We also implemented a manual approach for Thelypteridaceae, which had the highest number of non-monophyletic genera (16) in a previous version of FTOL (v1.0.0) and likely has high rates of misidentification in GenBank.
This approach used a curated list of accessions from a previous phylogenetic analysis of this family [@Patel2019].
After resolving the names in @Patel2019 to pteridocat and correcting some errors (incorrect GenBank accession number in a small number of cases), accessions in this list were used preferentially over those identified by the automated approach.

## Sequence alignment

For non-spacer regions (genes), we aligned each locus separately in MAFFT with automatic adjustment for sequence direction and other settings on default. Spacer regions are difficult to align across higher taxonomic levels within ferns (`r eg`, family or higher) as they include frequent indels; however, spacer regions are very useful for phylogenetic analysis at finer scales (`r eg`, within genus or family) where slower-evolving genes like *rbcL* may not provide enough resolution.
Therefore, we first aligned spacer regions for each family with MAFFT separately, then merged these subalignments using the MAFFT "\-\-merge" option.
This option retains the indels within each subalignment while aligning across subalignments.
Sequences from families with fewer than three species each could not be used for subalignments, so these were added as "singletons" during the MAFFT "\-\-merge".
Anemiaceae showed an extremely high number of indels compared to other families and could not be reliably aligned, so we excluded it from the spacer region data (*trnL*--*trnF* and *rps4*--*trnS*).
We also excluded outgroups from the spacer region data as they cannot be reliably aligned to ferns.

We removed poorly aligned regions, including those with >1% or >5% of sequences having gaps, from the alignments using trimAl [@Capella-Gutierrez2009].

## Phylogenetic analysis

### Backbone phylogeny

We generated a backbone phylogeny using maximum likelihood (ML) analysis of the concatenated plastome dataset in IQ-TREE v`r pkg_ver("iqtree2", pkg_versions)` [@Nguyen2015].
ModelFinder [@Kalyaanamoorthy2017] was implemented in IQ-TREE to select the best-fitting model of sequence evolution.
To reduce computational burden, we only tested models based on the General Time Reversible (GTR) model [@Tavare1986] and did not partition the dataset.
The best-fitting model was selected automatically by IQ-TREE according to Bayesian Information Criterion (BIC) score.
Node support was assessed with `r number(1000)` ultrafast rapid bootstrap replicates [@Minh2013; @Hoang2018], which were then used to construct an extended, majority-rule consensus tree (the "backbone phylogeny").

### Initial Sanger phylogeny

We used the backbone phylogeny as a constraint tree to conduct initial phylogenetic analysis of the concatenated Sanger dataset in IQ-TREE with the "-fast" option and the GTR+I+G model.
We prioritized computational speed for this step, as we needed to repeat it multiple times as described in the next section.

### Removal of rogue sequences based on initial Sanger phylogeny

We inspected the initial Sanger phylogeny to identify any remaining rogues or names that needed updating in the taxonomic database.
We checked for monophyly at taxonomic levels at or above genus using the MonoPhy R package v`r pkg_ver("MonoPhy", pkg_versions)` [@Schwery2016].
We updated our taxonomic database if the molecular data clearly indicated the current usage of a synonym was incorrect (`r eg`, a taxonomic intruder into an otherwise expected monophyletic genus with a synonym available for that genus; expected monophyly follows PPG I, 2016).
However, this was not possible in all cases, particularly in groups that are in need of taxonomic revision and are known to include non-monophyletic genera (`r eg`, cheilanthoid ferns, grammitid ferns, microsoroid ferns).
While we consider our phylogeny may serve as a guide for future taxonomic revisions, we did not make any taxonomic changes that were not already validly published according to the International Code of Nomenclature for Algae, Fungi, and Plants [@Turland2018].
Some unpublished names appearing in GenBank and World Ferns databases were not excluded.

Based on the results of this inspection, we updated the list of rogue accessions to be excluded, updated the taxonomic database, and then re-ran all analyses up to this step.
During each iteration of the analysis, it is possible that the GenBank accessions added in place of the excluded rogues themselves include rogues.
Therefore, we repeated this process until the monophyly of all higher-level (`r eg`, genus rank and higher) taxa that were expected to be monophyletic according to PPG I (2016) was either confirmed or could not be achieved due to outstanding taxonomic issues.

### Final Sanger phylogeny

We generated the final Sanger phylogeny using the backbone phylogeny as a constraint tree in ML analysis of the final concatenated Sanger dataset, with the same model selection procedure and bootstrapping as used for the backbone phylogeny.
IQ-TREE was initially run using 1,000 iterations (default), but at the end of this run the bootstrap correlation coefficient of split occurrence frequencies was 0.96, which is below the threshold for convergence (0.99).
We then continued the search for another 1,000 iterations (2,000 total), but the correlation coefficient fluctuated between 0.96 and 0.98 without overall improvement or convergence.
This suggests that the search was stuck in a local optimum.
As our alignment contains many species with very similar sequences, it is likely that the search algorithm is unable to optimize many highly similar topologies that only vary in positions of closely related species at the tips.
Considering that additional iterations were unlikely to converge, we therefore conducted 10 independent runs of IQ-TREE with 1,000 iterations each, and selected the run with the best (highest) combined log-likelihood of the ML and consensus trees [@Zhou2018].

We did not conduct a more exhaustive analysis testing various partitions of the data or other phylogenetic inference methods or models as our goal is to produce a single species-level phylogeny that is a reasonable hypothesis of fern evolution, not to interrogate the outcomes of multiple, more or less equally applicable methods.

## Molecular dating

```{r dating-methods-stats}
# Count total number of fern fossils in database
n_fern_fossils_total <- 
  fossil_ferns_raw %>%
  # Exclude non-fern fossils
  filter(!affinities %in% c("Euphyllophytes", "Tracheophytes")) %>%
  pull(fossil_taxon) %>%
  n_distinct() %>%
  number()

# Format fossils for printing in MS
fossils <-
  fossil_ferns_raw %>%
  mutate(age = number(minimum_age, accuracy = 0.1)) %>%
  split(.$affinities)

# Format values used for treePL smoothing as tibble
cv_smooth_test <-	
  tibble(cv_result = treepl_cv_results) %>%
  mutate(smooth = str_match(cv_result, "\\((.*)\\)") %>% 
           magrittr::extract(, 2) %>%
           parse_number()) %>%
  mutate(chisq = str_match(cv_result, "\\) (.*)$") %>% 
           magrittr::extract(, 2) %>%
           parse_number()) %>%
  arrange(smooth)

# Extract start, end, and best smooth values
smooth_start <- cv_smooth_test %>%
  slice_min(n = 1, order_by = smooth) %>%
  pull(smooth) %>%
  formatC(format = "e", digits = 0)

smooth_end <- cv_smooth_test %>%
  slice_max(n = 1, order_by = smooth) %>%
  pull(smooth) %>%
  formatC(format = "e", digits = 0)

smooth_best <-
  cv_smooth_test %>%
  slice_min(n = 1, order_by = chisq) %>%
  pull(smooth) %>%
  formatC(format = "e", digits = 0)
```

Dating was conducted separately on the ML tree and the consensus tree using penalized likelihood as implemented in the development version of treePL [commit starting with `r pkg_ver("treepl", pkg_versions)`\; @Smith2012].
We initially rooted the tree using *Zygnema circumcarinatum* Czurda, a member of the group of algae (Zygnematophyceae) thought to be most closely related to land plants [@Donoghue2021].
Since there is no way to objectively divide branch length between the branch leading to the outgroup and the rest of the tree, we then trimmed *Z. circumcarinatum* from the phylogeny; this effectively positioned bryophytes as the outgroup on a branch or branches with length(s) estimated from the data [@Sauquet2013].

We selected `r n_calibrations_ferns` fern fossils to use as constraints from ferncal v1.0.1, a newly curated database including `r n_fern_fossils_total` fern fossil taxa [@ftol2022b\; `r s_table("fossils")`, Appendix S2].
In the case of redundant fossils (those assignable to the same node in the phylogeny; `r eg`, stems of families that are sister to each other, such as Dipteridaceae and Matoniaceae) we selected the fossil with the oldest age (`r ie`, the upper limit of the oldest stratigraphic period assigned to the fossil). 
We assigned fossils to lineages only after consulting the original publication (as opposed to simply relying on the fossil name) so we could reassess the identification relative to changes in taxonomy and hypotheses of phylogenetic relationships.
Taxonomic concepts may vary between the original publication and currently applied taxonomy (`r eg`, Dicksoniaceae *sensu lato* including other tree fern families used in description of the fossil but Dicksoniaceae *sensu stricto* used currently) and hypotheses of phylogenetic relationships among extant species may change (`r eg`, *Dennstaedtia* used in description of a fossil but this genus now known to be polyphyletic); in both cases, the resulting node to be constrained with a given fossil could change.
We applied one fossil constraint outside of ferns (stem euphyllophytes; `r fossils$Euphyllophytes$age` Ma), and fixed the root age of the tree (land plants) at 475 Ma as in @Testo2016a and @Qi2018.
All constraints other than the root are minimum ages (`r s_figure("fossil_map")`).

We tested rate smoothing parameters in treePL ranging from `r smooth_start` to `r smooth_end` (each varies by one order of magnitude); these values were used because our tree spans a wide phylogenetic range with high rate heterogeneity, and because results of initial analyses with higher smoothing values sometimes produced spurious date estimates.
A value of `r smooth_best` was ultimately selected, based on the smallest chi-squared value, for the final analysis.

## Reproducibility

The workflow is managed in R v`r ftol_r_ver` [@RCoreTeam2022] with the targets R package v`r pkg_ver("targets", pkg_versions)` [@Landau2021].
Input data are available at https://doi.org/10.6084/m9.figshare.19474316 [@Nitta2022figshare].
Code used to generate FTOL and compile this manuscript are available at https://github.com/fernphy/ftol and https://github.com/fernphy/ftol_ms, respectively.
Docker images to run the analysis and compile this manuscript are available at https://hub.docker.com/r/joelnitta/ftol and https://hub.docker.com/r/joelnitta/ftol_ms, respectively.

# Results

## GenBank mining

```{r genbank-stats}
# Helper function to count number of GenBank accessions in a dataset
count_accs <- function(data) {
  data %>%
    pull(accession) %>%
    n_distinct() %>%
    number()
}

# Manual list of accessions to exclude
n_accs_exclude <-
  accs_exclude %>%
  pull(accession) %>%
  n_distinct() %>%
  number()

# Sanger ----

# Number of GenBank accessions resulting from inital query
n_accs_query <- count_accs(fern_sanger_seqs_raw)

# Number of GenBank accessions recovered with superCRUNCH
n_accs_extract <- count_accs(raw_fasta_all)

# Number of GenBank accessions after excluding manual rogues,
# names that couldn't be resolved
n_accs_first_filter <- count_accs(sanger_seqs_combined_filtered)

# Number of GenBank accessions after further excluding
# rogues based on BLAST
n_accs_second_filter <- count_accs(sanger_seqs_rogues_removed)

# Number of GenBank accessions in final selection, excluding plastome
# first convert to long form
sanger_accessions_selection_long <-
  sanger_accessions_selection %>%
  # Remove outgroup and plastome species
  anti_join(
    unique(select(plastome_seqs_combined_filtered, species)),
    by = "species") %>%
  # Remove plastome species
  select(contains("accession")) %>%
  pivot_longer(values_to = "accession", everything()) %>%
  filter(!is.na(accession))

# Count number of raw accessions in final Sanger selection
# (excluding plastome)
n_accs_raw_final <- count_accs(sanger_accessions_selection_long)

# Count number of accessions in final Sanger selection, split by locus
# (excluding plastome)
n_accs_final <- 
  sanger_accessions_selection_long %>%
  # Count accessions containing different loci as distinct
  mutate(
    name = str_remove_all(name, "accession_"),
    accession = paste(name, accession, sep = "_")) %>%
  count_accs()

# Count number of species in final Sanger selection
# (excluding plastome)
n_species_sanger <- 
  sanger_accessions_selection %>% 
  # Remove outgroup and plastome species
  anti_join(
    unique(select(plastome_seqs_combined_filtered, species)),
    by = "species") %>%
  pull(species) %>%
  n_distinct() %>%
  number()

# Analyze join by method
# (excluding plastome)
join_by_count <-
  sanger_accessions_selection %>% 
  # Remove outgroup and plastome species
  anti_join(
    unique(select(plastome_seqs_combined_filtered, species)),
    by = "species") %>%
  assert(not_na, join_by, species) %>%
  assert(is_uniq, species) %>%
  tabyl(join_by) %>%
  mutate(join_by = fct_reorder(join_by, n)) %>%
  mutate(
    percent = percent(percent, accuracy = 0.1),
    n = number(n, accuracy = 1)) %>%
  split(.$join_by)

# Plastome ----
# Don't include OG in calculations
n_plast_accs_query <-
  # initial search includes some accessions that were later excluded
  plastome_metadata_raw_all %>%
  left_join(
    select(plastome_metadata_renamed, accession, outgroup),
    by = "accession") %>%
  # excluded accessions lack outgroup info, but are all ferns
  mutate(outgroup = replace_na(FALSE)) %>%
  assert(not_na, outgroup) %>%
  filter(outgroup == FALSE) %>%
  count_accs()
n_plast_first_filter <-
  plastome_metadata_renamed %>%
  assert(not_na, outgroup) %>%
  filter(outgroup == FALSE) %>%
  count_accs()
n_accs_plast_final <- 
  plastome_seqs_combined_filtered %>%
  left_join(
    select(plastome_metadata_renamed, accession, outgroup),
    by = "accession") %>%
  assert(not_na, outgroup) %>%
  filter(outgroup == FALSE) %>%
  count_accs()
```

The initial GenBank query for the seven Sanger loci resulted in `r n_accs_query` accessions (note that in some cases a single GenBank accession may contain multiple loci).
Extraction of target loci with superCRUNCH recovered `r n_accs_extract` accessions.
Manual inspection of the initial tree resulted in a list of `r n_accs_exclude` rogues to be excluded.
After excluding these and accessions with names that could not be resolved to an accepted name in the taxonomic database, `r n_accs_first_filter` accessions were retained.
After further excluding rogues identified by the all-by-all BLAST search (`r s_table("rogues")`), `r n_accs_second_filter` accessions were retained.
The final selection of Sanger loci (one set of concatenated accessions per species or one accession per species if conditions for concatenation were not met) after excluding species in the plastome dataset included `r n_accs_raw_final` accessions (`r n_accs_final` sequences when counting distinct loci within each accession separately; `r s_table("accs")`) representing `r n_species_sanger` species.
The most frequent method for joining accessions across loci was by `r last(join_by_count)$join_by` (`r last(join_by_count)$n` species; `r last(join_by_count)$percent`); `r join_by_count$unjoined$n` species (`r join_by_count$unjoined$percent`) had accessions that could not be joined or only included one of the seven loci (`r s_table("join_by")`).

The initial GenBank query for fern plastomes resulted in `r n_plast_accs_query` accessions, of which `r n_plast_first_filter` accessions were retained after excluding rogues and species with names that could not be resolved.
Selection of the longest set of concatenated sequences per species yielded `r n_accs_plast_final` accessions representing unique species (`r s_table("accs")`).

## Taxon and locus sampling

```{r sampling-stats, message = FALSE}
# Taxon sampling ----
# Format FTOL sampling as list
tax_coverage <-
  coverage_by_rank %>%
  filter(rank == "major_clade") %>%
  transmute(
    # Be sure to change to factor so list is correct order
    # when splitting
    clade = fct_reorder(name, coverage),
    coverage = percent(coverage, accuracy = 0.1)) %>%
  split(.$clade)

# Format overall FTOL sampling as list
total_sampling <- split(total_coverage, total_coverage$rank)

# Format overall plastome (backbone) sampling as list
bb_total_sampling <- split(bb_total_coverage, bb_total_coverage$rank)

# Locus sampling ----
# Make tibble with one row per locus per species
sanger_locus_sampling <-
  sanger_alignment_tbl %>%
  mutate(taxon = map(align_trimmed, rownames)) %>%
  select(locus = target, species = taxon) %>%
  unnest(cols = species) %>%
  # Exclude outgroups
  left_join(
    unique(select(sanger_sampling, species, outgroup)), by = "species") %>%
  filter(outgroup == FALSE) %>%
  select(-outgroup)

# Summarize mean number of loci per species
locus_summ <-
  sanger_locus_sampling %>%
  group_by(species) %>%
  summarize(
    n_loci = n_distinct(locus)
  ) %>%
  summarize(
    max = max(n_loci) %>% number(accuracy = 1),
    min = min(n_loci) %>% number(accuracy = 1),
    mean = mean(n_loci) %>% number(accuracy = 0.1),
    sd = sd(n_loci) %>% number(accuracy = 0.1)
  )

# Format total number of samples per locus as list for MS
locus_total <-
  sanger_locus_sampling %>%
  count(locus) %>%
  mutate(
    locus = fct_reorder(locus, n),
    n = number(n)) %>%
  split(.$locus)

# Make tibble with number of species per locus combination
locus_comb_tib <-
  sanger_locus_sampling %>%
  group_by(species) %>%
  summarize(comb = paste(sort(locus), collapse = "_")) %>%
  count(comb) %>%
  arrange(desc(n)) %>%
  mutate(
    rbcl_present = str_detect(comb, "rbcL"),
    n_loci = str_count(comb, "_") + 1)

# Format as list for MS
locus_comb <-
  locus_comb_tib %>%
  mutate(
    comb = fct_reorder(comb, n),
    n = number(n, accuracy = 1)) %>%
  split(.$comb)

# Verify the most frequent locus combination is rbcL alone
assertthat::assert_that(
  locus_comb_tib %>%
    filter(n == max(n)) %>%
    pull(comb) == "rbcL")

# Verify that the second most frequent locus combination is all seven species
assertthat::assert_that(
  locus_comb_tib %>%
    arrange(desc(n)) %>%
    slice(2) %>%
    pull(n_loci) == 7)

# Calculate number of species with > 1 locus
sp_mult_loci <-
  sanger_locus_sampling %>%
  group_by(species) %>%
  summarize(mult_loci = if_else(n_distinct(locus) > 1, "true", "false")) %>%
  tabyl_fmt(mult_loci) %>%
  split(.$mult_loci)

# Backbone locus sampling ----
bb_locus_tbl <-
  plastome_alignment_tbl %>%
  mutate(taxon = map(align_trimmed, rownames)) %>%
  select(locus = target, species = taxon) %>%
  unnest(cols = species) %>%
  group_by(species) %>%
  summarize(n_loci = n_distinct(locus)) %>%
  arrange(desc(n_loci)) %>%
  left_join(
    unique(select(sanger_sampling, species, outgroup)), by = "species") %>%
  filter(outgroup == FALSE) %>%
  select(-outgroup)

bb_locus_summ <-
  bb_locus_tbl %>%
  summarize(
    max = max(n_loci) %>% number(accuracy = 1),
    min = min(n_loci) %>% number(accuracy = 1),
    mean = mean(n_loci) %>% number(accuracy = 0.1),
    sd = sd(n_loci) %>% number(accuracy = 0.1)
  )

bb_with_all_loci <-
  bb_locus_tbl %>%
  mutate(all_loci_sampled = if_else(n_loci == 79, "true", "false")) %>%
  tabyl_fmt(all_loci_sampled) %>%
  split(.$all_loci_sampled)
``` 

Taxon sampling for FTOL v1.1.0 includes `r total_sampling$species$coverage` species (`r total_sampling$species$coverage_p`), `r total_sampling$genus$coverage` genera (`r total_sampling$genus$coverage_p`), `r total_sampling$family$coverage` families, and `r total_sampling$order$coverage` orders of ferns (all coverage values are relative to the number of accepted species in pteridocat v`r pkg_ver("pteridocat", pkg_versions)`).
Coverage varied by major clade from `r tax_coverage %>% first %>% extract2("coverage")` (`r tax_coverage %>% first %>% extract2("clade")`) to `r tax_coverage %>% last %>% extract2("coverage")` (`r tax_coverage %>% last %>% extract2("clade")`) (`r figure("ftol")`). Taxon sampling for the backbone phylogeny (derived from plastome loci) includes `r bb_total_sampling$species$n` species (`r bb_total_sampling$species$coverage_p`), `r bb_total_sampling$genus$coverage` genera (`r bb_total_sampling$genus$coverage_p`), `r bb_total_sampling$family$coverage` families (`r bb_total_sampling$family$coverage_p`), and `r bb_total_sampling$order$coverage` orders of ferns.

The number of fern species sampled per locus in the Sanger dataset ranged from `r first(locus_total)$n` (*`r first(locus_total)$locus`*) to `r last(locus_total)$n`  (*`r last(locus_total)$locus`*).
A majority of species (`r sp_mult_loci$true$n`; `r sp_mult_loci$true$percent`) were sampled for more than one locus.
A mean of `r locus_summ$mean` ± `r locus_summ$sd` loci were sampled per species (all errors are standard deviations unless otherwise mentioned).
The most frequent type of locus sampling per species was *rbcL* alone (`r locus_comb$rbcL$n` species) (`r s_figure("locus-upset")`).
The second most frequent type of locus sampling per species was all seven loci together (`r nth(locus_comb, length(locus_comb) - 1)$n` species). 
Locus sampling per species in the plastome dataset ranged from `r bb_locus_summ$min` to `r bb_locus_summ$max` (mean `r bb_locus_summ$mean` ± `r bb_locus_summ$sd` loci per species); `r bb_with_all_loci$true$n` species (`r bb_with_all_loci$true$percent` of plastome species) included all 79 loci.

## DNA alignments

```{r dna-stats}
# Calculate frequency of missing bases in each dataset overall
plastome_missing_freq <- base_freq_missing(plastome_alignment) %>%
  percent(accuracy = 0.1)
sanger_missing_freq <- base_freq_missing(sanger_alignment) %>%
  percent(accuracy = 0.1)

# Calculate frequency of missing bases by locus for Sanger loci
# Concatenate Sanger loci again here to be sure order is the same
sanger_genes_cat <- do.call(
  ape::cbind.DNAbin,
  c(sanger_alignment_tbl$align_trimmed, fill.with.gaps = TRUE))

sanger_missing_by_gene <-
  # Get start and end position of each gene in concatenated alignment
  sanger_alignment_tbl %>%
  mutate(
    nbp = map_dbl(align_trimmed, ncol),
    end = cumsum(nbp),
    start = end - nbp + 1) %>%
  # Calculate frequency of missing data
  select(gene = target, start, end) %>%
  mutate(
    missing = map2_dbl(
      start, end,
      ~base_freq_missing(
        seqs = sanger_genes_cat,
        start = .x,
        end = .y))
  ) %>%
  select(-start, -end) %>%
  # Reorder and split for printing
  mutate(
    # Format gene names for printing
    gene = str_replace_all(gene, "-", "--"),
    gene = str_replace_all(gene, "([^-]+)", "*\\1*"),
    gene = fct_reorder(gene, missing),
    missing = percent(missing)) %>%
  split(.$gene)
```

The Sanger DNA alignment was `r number(ncol(sanger_alignment))` bp with `r sanger_missing_freq` missing data (missing bases or gaps) overall; rates of missing data by locus ranged from `r sanger_missing_by_gene %>% first() %>% extract2("missing")` (`r sanger_missing_by_gene %>% first() %>% extract2("gene")`) to `r sanger_missing_by_gene %>% last() %>% extract2("missing")` (`r sanger_missing_by_gene %>% last() %>% extract2("gene")`).
The plastome DNA alignment was `r number(ncol(plastome_alignment))` bp with `r plastome_missing_freq` missing data. 

## Phylogeny

```{r phylogeny-stats-log}
sanger_log_files <- fs::dir_ls(
 here::here("ftol_cache/user/intermediates/iqtree/"),
 recurse = TRUE,
 regexp = "sanger_[0-9]+/sanger_alignment.phy.log"
 )

rename_sanger <- function(x) {
  names(x) <- str_match(names(x), "sanger_[0-9]") %>%
    magrittr::extract(,1)
  x
}

sanger_ml_log_rep <- sanger_log_files %>%
  map(read_lines) %>%
  unlist()

ml_scores <- sanger_ml_log_rep[
  str_detect(sanger_ml_log_rep, "BEST SCORE FOUND")] %>%
  rename_sanger() %>%
  map_dbl(parse_number)

con_scores <- sanger_ml_log_rep[
  str_detect(sanger_ml_log_rep, "Log-likelihood of consensus tree")] %>%
  rename_sanger() %>%
  map_chr(~str_remove_all(., "Log-likelihood of consensus tree: ")) %>%
  map_dbl(parse_number)
combined_scores <- ml_scores + con_scores

assertthat::assert_that(
  !any(is.na(ml_scores))
)
assertthat::assert_that(
  !any(is.na(con_scores))
)
assertthat::assert_that(
  length(ml_scores) == length(con_scores),
  msg = "Length of ML and consensus scores don't match"
)

best_index <- which(combined_scores == max(combined_scores))
best_ml_score <- ml_scores[best_index]
best_con_score <- con_scores[best_index]

assertthat::assert_that(
  best_ml_score < best_con_score,
  msg = "Best ML score not less than best consensus score"
)

# check model selected
sanger_models <- sanger_log_files %>%
  map(read_lines) %>%
  map(extract_iqtree_mod) %>%
  map(unique) %>%
  rename_sanger()

assertthat::assert_that(
  length(unique(sanger_models)) == 1,
  msg = "More than one sanger model selected"
)
assertthat::assert_that(
  extract_iqtree_mod(plastome_iqtree_log) == unique(sanger_models),
  msg = "Model selected for plastome and sanger don't match"
)

# check number of runs converged
no_converge <- sanger_ml_log_rep[
  str_detect(sanger_ml_log_rep, "bootstrap analysis did not converge")] %>%
  rename_sanger()
n_converge <- length(sanger_log_files) - length(no_converge) %>%
  english::english()

assertthat::assert_that(
  names(best_index) %in% names(no_converge),
  msg = "Best scoring tree *did* converge")
```

```{r phylogeny-stats}
# Bootstrap values for selected clades
ferns_bs <- get_bs(plastome_tree_rooted, c("Equisetum_arvense", "Danaea_nodosa"))
hym_gle_bs <- get_bs(plastome_tree_rooted, c("Dipteris_conjugata", "Hymenophyllum_polyanthos"))
cyath_salv_bs <- get_bs(plastome_tree_rooted, c("Plagiogyria_adnata", "Azolla_filiculoides"))
denn_poly_bs <- get_bs(plastome_tree_rooted, c("Dennstaedtia_hirsuta", "Pseudophegopteris_aurita"))

# Tibble of bootstrap for consensus trees
bs_tib <-
  tibble(bs = sanger_con_tree_rooted$node.label, dataset = "sanger") %>%
  bind_rows(tibble(bs = plastome_tree_rooted$node.label, dataset = "plastome")) %>%
  mutate(
    bs = na_if(bs, "Root") %>% 
      parse_number
  )

# Percent of plastome phylogeny with 100% BS support
plastome_bs100 <-
  bs_tib %>%
  filter(dataset == "plastome") %>%
  filter(!is.na(bs)) %>%
  mutate(is_100 = if_else(bs == 100, "true", "false")) %>%
  tabyl(is_100) %>%
  mutate(percent = percent(percent, accuracy = 0.1)) %>%
  split(.$is_100)

# Mean BS values for printing
bs <-
  bs_tib %>%
  group_by(dataset) %>%
  summarize(
    mean = mean(bs, na.rm = TRUE),
    sd = sd(bs, na.rm = TRUE)
  ) %>%
  mutate(across(c(mean, sd), ~number(., accuracy = 0.1))) %>%
  split(.$dataset)

# Format monophyly status as list for MS
fern_monophy_summ <-
  fern_monophy_summ_tbl %>%
  mutate(
    n = as.integer(n),
    p = percent(percent, accuracy = 1)
  ) %>%
  split(.$tax_level) %>%
  map(~split(., .$monophyly))

top_nonmono_subfam <-
  fern_nonmono_gen %>%
  group_by(family, subfamily) %>%
  summarize(n = n(), .groups = "drop") %>%
  slice_max(n = 3, order_by = n) %>%
  assert(not_na, family, subfamily) %>%
  mutate(subfamily = fct_reorder(subfamily, n)) %>%
  mutate(n = map_chr(n, jntools::english2)) %>%
  arrange(desc(subfamily))

# Double check that non-monophyletic genera outside of
# top three non-monophyletic subfamilies all have less
# than four genera each
fern_nonmono_gen %>%
  anti_join(
    top_nonmono_subfam,
    by = c("family", "subfamily")) %>%
  count(family, subfamily) %>%
  verify(
    all(n < 4), 
    error_fun = error_msg(
      "Other subfamilies besides top three don't have less than four genera each"),
    success_fun = success_logical)

# Check that model for plastome and sanger was same
assertthat::assert_that(
  unique(extract_iqtree_mod(sanger_iqtree_log_2000)) == 
    unique(extract_iqtree_mod(plastome_iqtree_log)),
  msg = "Same model not selected for plastome and sanger trees"
)
```

The `r extract_iqtree_mod(plastome_iqtree_log)` model was selected according to BIC for both the plastome (backbone) and Sanger analyses.
`r str_to_sentence(n_converge)` of the ten runs converged (correlation coefficient of split occurrence frequencies >0.99), but the run with the highest log-likelihood, from which the final tree was selected, did not converge (correlation coefficient 0.976 after `r number(1000)` iterations).
The consensus tree had higher log-likelihood (`r number(best_con_score)`) than the ML tree (`r number(best_ml_score)`), so we only present the topology and divergence times estimated from the consensus tree.

Ferns are strongly supported as monophyletic (BS `r ferns_bs`; all subsequent relationships mentioned received BS ≥ `r percent(.98)` in the backbone phylogeny unless otherwise indicated).
The first split within ferns separates a clade including Equisetidae and Ophioglossidae from all other species (Figures `r figure_num("backbone")`, `r s_figure_num("backbone_full")`).
The next split separates Marattiales from the remaining ferns, the leptosporangiates (Polypodiidae).
Within leptosporangiate ferns, Osmundales is sister to all other species.
The next lineage to diverge is a clade including Hymenophyllales and Gleicheniales (BS `r hym_gle_bs`), followed by Schizaeales.
Salviniales was recovered as sister to Cyatheales, which are in turn sister to Polypodiales. 
The first split within Polypodiales separates a clade including Saccolomatineae and Lindsaeineae from the remainder of species, followed by the subsequent divergences of Pteridineae, then Dennstaedtiineae, which is sister to the eupolypods with moderate support (BS `r denn_poly_bs`).
There are two major clades within eupolypods, Polypodiineae (eupolypods I) and Aspleniineae (eupolypods II).

All sampled orders, suborders, families, and subfamilies were recovered as monophyletic (or monotypic) with the exception of Polypodioideae, which is known to be paraphyletic relative to Grammitidoideae (PPG I, 2016).
`r fern_monophy_summ$genus$No$n %>% english::english() %>% str_to_sentence()` genera (`r fern_monophy_summ$genus$No$p`) were non-monophyletic (`r s_table("monophy")`).
The subfamilies with the most non-monophyletic genera were `r top_nonmono_subfam$subfamily[[1]]` (`r top_nonmono_subfam$n[[1]]`), `r top_nonmono_subfam$subfamily[[2]]` (`r top_nonmono_subfam$n[[2]]`), and `r top_nonmono_subfam$subfamily[[3]]` (`r top_nonmono_subfam$n[[3]]`); other (sub)families each had four or fewer non-monophyletic genera (`r s_table("nonmono_gen")`).

Bootstrap support was generally moderate to high across the tree (mean `r bs$sanger$mean` ± `r bs$sanger$sd`; Sanger phylogeny) and particularly high at deeper nodes (mean `r bs$plastome$mean` ± `r bs$plastome$sd`; `r plastome_bs100$true$percent` of nodes with 100% BS; backbone phylogeny).
Relationships within some genera were less well-supported, including *Cyathea*, *Amauropelta*, and parts of *Dryopteris* and *Elaphoglossum* (`r s_figure("bs")`).

## Divergence times

We estimate the crown age of ferns to be `r crown_ages$ferns` million years (Ma) old.
Ages of other major crown groups are: leptosporangiates (`r crown_ages$leptos` Ma), Polypodiales (`r crown_ages$polypodiales` Ma), eupolypods I (`r crown_ages$eupoly_i` Ma), and eupolypods II (`r crown_ages$eupoly_ii` Ma).
Our estimates for leptosporangiates and Polypodiales are both `r ca` 30--40 Ma older than the most recent global fern phylogeny [@Testo2016a], while other ages are similar (eupolypods I) or slightly younger (eupolypods II).
Estimated stem ages of fern families were mostly older than previous studies (`r figure("divtimes")`).
We did not compare crown ages of families across studies because differences in crown ages of smaller clades are likely affected by species sampling.

# Discussion

## Nodes of contention in fern phylogeny

```{r phy-discussion-stats}
# Calculate number of genera sampled for Gleicheniales
ppgi_gleich_genera_n <-
  ppgi_taxonomy %>%
  filter(order == "Gleicheniales") %>%
  pull(genus) %>%
  n_distinct()

plastome_gleich_genera_n <-
  bb_coverage_by_rank %>%
  left_join(select(ppgi_taxonomy, name = genus, order), by = "name") %>%
  filter(order == "Gleicheniales") %>%
  pull(name) %>%
  n_distinct()
```

The phylogenetic position of Equisetidae relative to other ferns has long been contentious.
Here, we recovered Equisetidae as sister to Ophioglossidae (Psilotales + Ophioglossales), in agreement with many other plastid phylogenomic analyses [@Grewe2013; @Ruhfel2014; @Gitzendanner2018b; @Lehtonen2019; @Kuo2018; @OneThousandPlantTranscriptomesInitiative2019].
However, this contradicts nuclear phylogenomic analyses [@Rothfels2015a; @Qi2018; @Shen2018; @OneThousandPlantTranscriptomesInitiative2019], most plastid analyses with smaller numbers (`r ca` 3--17) of genes [@Schneider2004d; @Rai2010; @Kuo2011; @Testo2016a] and an analysis including mitochondrial data [@Knie2015], which have all recovered Equisetidae as sister to all other ferns.
Some earlier plastid analyses based on Sanger data also recovered Equisetidae sister to Marattidae, albeit with generally low support [@Pryer2001; @Qiu2006; @Qiu2007].
Aside from alternative resolutions of Equisetidae dependent on genomic compartment or model parameters [@Wickett2014; @Kuo2018], structural support exists for both Equisetidae as sister to Ophioglossidae [`r ca` 550 bp intron in plastid *rps12*\; @Grewe2013] and Equisetidae as sister to all other ferns [`r ca` 70 bp intron in mitochondrial *rpl2*\; @Knie2015].
The clear contradiction between plastid and nuclear phylogenomic data may indicate ancient hybridization or introgression, but robust support for any particular scenario is so far lacking.

Another enigmatic relationship in ferns is the placement of Hymenophyllales.
The monophyly of Polypodiidae (leptosporangiate ferns) is well supported across many studies and not in doubt, as is the status of Osmundales as the first lineage to diverge from the remainder of leptosporangiates [@Pryer2001; @Schneider2004d; @Schuettpelz2007; @Kuo2011; @Testo2016a].
However, the subsequent placement of Hymenophyllales differs across studies: some recover Hymenophyllales as the next diverging lineage after Osmundales [@Pryer2001; @Testo2016a; @Schneider2004d; @Schuettpelz2006; @Schuettpelz2007], while others recover a clade comprising Hymenophyllales sister to Gleicheniales, which then together are sister to the remaining (non-Osmundales) leptosporangiates [@Pryer2004a; @Lehtonen2017].
Another possibility supported by recent transcriptomic studies is Hymenophyllaceae sister to Gleicheniaceae, which are in turn sister to Dipteridaceae, resulting in a paraphyletic Gleicheniales [@Qi2018; @Shen2018; @Shu2022].
Here, we recovered a monophyletic Gleicheniales sister to Hymenophyllales with moderate support, a relationship that was also observed in some, but not all, analyses of plastome data by @Lehtonen2019 and @Kuo2018.
However, our plastome sampling only includes `r plastome_gleich_genera_n %>% jntools::english2()` out of `r ppgi_gleich_genera_n` genera of Gleicheniales, and lacks Matoniaceae.
While our study was in revision, 42 additional fern plastomes were published, including seven families (`r ie`, Anemiaceae, Culcitaceae, Dipteridaceae, Loxsomataceae, Matoniaceae, Metaxyaceae, and Thyrsopteridaceae) that are not included in our sampling since they were not in the most recent available GenBank release at the time of our analysis [release 249\; @Du2022]. 
The addition of Matoniaceae results in non-monophyly of Gleicheniales, with Matoniaceae sister to Dipteridaceae, and these together sister to the remaining leptosporangiates [@Du2022].
Furthermore, @Du2022 did not recover a sister relationship between Hymenophyllaceae and Gleicheniaceae.
Interestingly, addition of Matoniaceae transcriptome data also supported the non-monophyly of Gleicheniales and the sister status of Matoniaceae + Dipteridaceae in another recent study [@Shu2022].

Within Polypodiales, the relationship between suborders Pteridineae, Dennstaedtiineae and the eupolypods (Polypodiineae and Aspleniineae) has been difficult to resolve (here designated "P", "D", and "e", respectively).
Most previous plastid studies based on Sanger sequencing have recovered (D, (P, e)) [@Kuo2011; @Schuettpelz2006; @Schuettpelz2007; @Testo2016a; but see @Lehtonen2011].
We recover (P, (D, e)) with moderate support (BS `r denn_poly_bs`); this topology agrees with other phylogenomic studies based on whole plastomes [@Lu2015a; @Lehtonen2019] and nuclear data [@Rothfels2015a; @Qi2018; @Shen2018], as well as a plastid supermatrix [@Lehtonen2011].
The whole plastome study of @Du2021 recovered a novel topology comprising ((D, P), e) under some analysis settings but (P, (D, e)) under others; a similar study with expanded sampling generally supported ((D, P), e) [@Du2022].

Although some relationships within Polypodiineae (eupolypods I) had previously been resolved differently between various studies using Sanger sequencing, such as Nephrolepidaceae sister to Lomariopsidaceae [@Schuettpelz2007; @Zhang2015] vs. Nephrolepidaceae sister to Tectariaceae, Oleandraceae, Davalliaceae, and Polypodiaceae [@Kuo2011; @Lehtonen2011; @Liu2013; @Testo2016a], our study is in agreement with both nuclear [@Qi2018; @Shen2018] and plastid phylogenomic analyses [@Du2021; @Du2022] that support the latter. Similarly, although Didymochlaenaceae had previously been identified as either sister to the remainder of Polypodiineae [@Kuo2011; @Zhang2015; @Testo2016a] or nested with Hypodematiaceae [@Schuettpelz2007; @Lehtonen2011] by studies using Sanger sequencing, our study as well as nuclear [@Qi2018] and plastid phylogenomic analyses [@Du2021; @Du2022] indicate that Hypodematiaceae is sister to the remainder of the clade.

Relationships of families within Aspleniineae (eupolypods II) have been difficult to resolve due to the ancient, rapid radiation of this clade [@Rothfels2012].
Our analysis robustly resolves the relationships between all families in Aspleniineae and is in agreement with a recent plastome analysis with similar sampling [@Du2021].
Notably, previous phylogenomic studies that had different or less well-supported topologies did not sample all eupolypod II families [Desmophlebiaceae and Hemidictyaceae absent\; @Wei2017a; @Qi2018; @Shen2018].
The family sister to the remainder of Aspleniineae has been resolved as either Aspleniaceae [`r eg`, @Schneider2004d; @Testo2016a; @Shen2018] or Cystopteridaceae [`r eg`, @Kuo2011; @Wei2017a; @Qi2018].
Here, we recovered Cystopteridaceae as sister to the remainder of eupolypod II families, which are split into two clades.
One clade consists of Rhachidosoraceae, Diplaziopsidaceae, Aspleniaceae, Desmophlebiaceae, and Hemidictyaceae [RHADD clade of @Du2021; Clade E of @Sundue2013].
The other clade includes Thelypteridaceae, Woodsiaceae, Athyriaceae, Onocleaceae, and Blechnaceae [WOBAT clade of @Du2021; Clade B of @Sundue2013].
Each of these two clades is supported by morphological synapomorphies [@Sundue2013; @Du2021].

Taken together, our results for nodes of contention in the fern phylogeny generally agree with other plastid phylogenomic analyses and are well within the realm of plausible hypotheses generated to date.
We do not consider any of these nodes "solved" by our analysis.
Rather, conclusive resolution apparently still awaits additional sampling and perhaps innovation in phylogenetic methods.

## Revisiting the timeline of fern diversification

```{r calibration-stats}
ftol_ts_comp_stats <-
ftol_ts_comp_mod %>%
  broom::glance()
```

We recovered older crown ages for ferns and large clades therein, and older stem ages for families relative to previous studies (Figures `r figure_num("divtimes")`, `r s_figure_num("du-ages")`).
This is almost certainly due to our use of a completely revised and greatly expanded set of fossil calibration points relative to previous studies, which not only resulted in a more densely constrained tree but also a higher number of fern families with minimum fossil ages.
Our set of fossil calibration points did not add any extremely old fossils (> 200 Ma) that would be expected to strongly push back ages across the tree [save for stem Marattiaceae, which is well-known for its extensive fossil record\; @Rothwell2018]; rather, the vast majority of newly added calibration points are younger than 150 Ma (`r s_figure("comp-fossils")`).

Several recent studies exploring divergence times across a global fern phylogeny all used a similar set of 24--26 fossil calibration points [@Schuettpelz2009; @Testo2016a] or secondary calibration points based on studies using this set [@Rothfels2015a].
However, there were a few inconsistencies in the application of these fossils due to differences in taxonomic concepts between the original fossil publication and the studies in which they were used.
More importantly, our set of calibration points approximately doubles the number used by previous studies and it is likely that this expanded dataset is responsible for the older stem age estimates for many families (Figures `r figure_num("divtimes")`, `r s_figure_num("du-ages")`).
To test this hypothesis, we conducted an additional analysis using the fossil constraints of @Testo2016a but otherwise the same methods (FTOL analyzed with treePL; `r s_figure("ts_fossil_map")`).
The resulting stem family ages show a much closer agreement with those of @Testo2016a (`r r2` = `r ftol_ts_comp_stats$r.squared %>% number(accuracy = 0.01)`, `r pval` = `r ftol_ts_comp_stats$p.value %>% sci_number()`, linear model; Figures `r s_figure_num("comp-stem-ages")`, `r s_figure_num("comp-stem-points")`), indicating that our expanded set of fossil calibration points, not differences in topology or dating methodology, is the primarily contributor to the older ages observed in the current study.

Notably, the scenario of fern diversification suggested by our results somewhat conflicts with the hypothesis that Polypodiales diversified "in the shadow of angiosperms" [@Schneider2004d; @Schuettpelz2009].
Rather, we estimate that the origin (`r ie`, stem age) of many polypod families coincides with or even precedes the diversification and rise to ecological dominance of angiosperms during the Late Cretaceous [@Benton2022] (`r s_figure("ltt")`).
Our estimated age of (`r crown_ages$polypodiales` Ma) for crown Polypodiales is considerably older than other recent studies [@Testo2016a; @Du2021] and the fossil record, which only dates back to the Early Cretaceous [@Schneider2001; @Chen1997; @Deng2002; @Schneider2016c; @Regalado2018a].
Molecular ages that are significantly older than the fossil record should be treated with caution; yet, our study is in agreement with others in suggesting a "long fuse" between initial appearance of Polypodiales and their subsequent diversification and widespread preservation in the fossil record [@Testo2016a; @Du2021].

Due to the large size of our dataset, carrying out more detailed molecular dating analyses (`r eg`, Bayesian analysis) is computationally difficult with currently available methods [`r eg`, BEAST\; @Drummond2007; @Bouckaert2014].
Here, we have prioritized computational speed and simplicity, since we anticipate re-running the pipeline on a regular basis.
We therefore consider our dated tree as a starting point, and not the final word, for a re-evaluation of divergence times in ferns.
Future studies should focus on utilizing our greatly expanded fern fossil dataset to conduct more thorough molecular dating analyses, possibly including alternative schemes for the age of the root and testing the effects of different parameters used for setting priors in Bayesian analyses.

## Plastid vs. nuclear fern trees

Plastid sequences are convenient for phylogenetic analysis because they are essentially a single, uniparentally inherited linkage group, thus free from recombination.
However, a tree derived from plastid data may not necessarily mirror those inferred from other data sources.
Conflict between plastid and nuclear phylogenies has been frequently observed in narrowly focused (`r eg`, genus level) studies using traditional Sanger sequencing [`r eg`, @Sessa2012b; @Zhou2017a; @Wei2021a] and has recently been demonstrated at deeper levels within Polypodiaceae using phylogenomic approaches [@Wei2022].
Such conflict does not necessarily reflect insufficient methodology or sampling, but rather may be due to processes including (but not limited to) introgression, lineage sorting, and hybridization at deep phylogenetic levels. 
Therefore, a major future research goal for fern molecular systematics should be to combine nuclear and plastid datasets to infer species trees with comprehensive sampling.

Recent transcriptomic studies are gradually clarifying the backbone of the fern phylogeny using many (25--`r number(2400)`) nuclear genes from representative species spanning the tree [@Rothfels2015a; @Qi2018; @Shen2018].
The most comprehensively sampled phylogenomic study targeting ferns is the on-going Genealogy of Flagellate Plants (GoFlag) project, which seeks to generate genomic data (`r ca` `r number(300)` single-to-low copy nuclear gene regions) for all flagellate plants [bryophytes, lycophytes, ferns, and gymnosperms\; @Breinholt2021].
GoFlag data have recently been used in a phylogenomic analysis and taxonomic revision of Thelypteridaceae resulting in the recognition of multiple new genera [@Fawcett2021; @Fawcett2021a], and additional phylogenomic analyses of other fern groups using GoFlag markers are to be expected in the near future.

The rapid growth of genomic data notwithstanding, species level sampling of such nuclear phylogenomic datasets is still far less than that available from the plastome (`r figure("genbank")`).
Furthermore, many subclades of ferns are under active investigation using both Sanger and next-gen sequencing of plastid markers, and plastid data for previously unsampled species will likely continue to grow at a rapid pace.
We therefore expect that the methodology outlined here will continue to be useful to generate a maximally sampled plastid fern tree of life for many years to come.

## Comparison with other automated phylogeny pipelines

Ferns are not unique in having large amounts of publicly available DNA sequence data, and several pipeline tools exist that can leverage such data to automatically generate phylogenies [@Antonelli2016; @Bennett2018; @Drori2018a; @Pearse2013; @Portik2020; @Smith2019; @Xu2015].
In particular, superSMART [@Antonelli2016] and pyPHLAWD [@Smith2019] are recently developed pipelines that can generate maximally sampled phylogenies for any higher taxon of choice.
The latter was used to generate a broadly inclusive seed plant phylogeny [@Smith2018].

Although we make use of some of the functionality of these tools [`r eg`, restez for generating a local copy of GenBank\; superCRUNCH for identifying orthologous sequences\; @Bennett2018a; @Portik2020], our pipeline is mostly custom-built for ferns.
We chose our approach because it allowed us to implement various steps specific to ferns that would not be possible using a fully automated, taxon-agnostic pipeline like superSMART or pyPHLAWD, which we believe ultimately results in a higher-quality fern phylogeny.
For example, we integrate our phylogeny with a custom taxonomy for ferns (pteridocat), tailor alignment strategies to locus and taxon (fern-wide alignment for coding loci, nested alignment within families for non-coding loci), inspect intermediate results and modify input based on expert taxonomic knowledge (curation of sample inclusion and exclusion lists), and employ a custom set of criteria for selecting and concatenating sequences within species.
While we have not sought to make our workflow available as a general tool due to its high degree of specialization, some of the methods employed here could be adapted and implemented in other phylogeny pipelines.

## Accesibility and usage of FTOL

We have sought to make FTOL easily available to support research on the evolution and ecology of ferns.
FTOL is available via the ftolr R package [@ftol2022c], and a web portal (https://fernphy.github.io).
Furthermore, we have made all the underlying data (`r eg`, DNA alignments, fossil calibrations) available so that other researchers can use these to conduct analyses such as further investigations of divergence times or phylogenetic analysis including custom sets of DNA sequences [`r eg`, @Nitta2022a].

A typical step in any analysis that joins data across multiple sources (`r eg`, trait data and a phylogeny) is to resolve taxonomic names so that the usage of synonyms does not prevent data merging [@Page2008].
During the preparation of FTOL, we developed two additional R packages that enable taxonomic name resolution to join data with FTOL: pteridocat [@ftol2022a] and taxastand [@joel_nitta_2021_5726391].
We selected R because it is widely used by the biological research community, well established, and freely available [@Lai2019].
The pteridocat package includes the pteridocat taxonomic database as a data frame (tibble) in Darwin Core format.
The taxastand package includes functions to resolve taxonomic names while taking into account variation in taxonomic author format and orthographic variation.
By using these two packages in combination, it should be straightforward for other researchers to map their own data onto FTOL, thus greatly enabling and enhancing studies including, but not limited to, comparative phylogenetics, biogeography, and community ecology in ferns.

## FTOL as a living, community-driven resource

We want to be clear that FTOL is in no way meant to be the "official" fern phylogeny; it is simply one reasonable hypothesis that has been designed to be maximally inclusive at the species level.
FTOL cannot substitute for careful systematic studies at finer taxonomic scales that include sampling of multiple individuals per species and/or other sources (`r eg`, morphological, nuclear) of data, and such studies continue to be vital to our understanding of fern evolution.

One feature of FTOL that sets it apart from the vast majority of other phylogenetic studies is its iterative nature.
Unlike most other published fern phylogenies, the current version of FTOL described in this manuscript is not meant to be the last.
Rather, we plan to re-run these analyses as additional data become available on GenBank, and release updated versions of the tree on a regular basis.
We envision that FTOL will be integrated with the next iteration of the Pteridophyte Phylogeny Group classification, PPG II, to provide the most recent hypotheses on the monophyly of various fern taxa, which will in turn enable a more natural classification system.

Furthermore, FTOL will not only grow in size with time, but also become more refined.
We are aware that our methodology cannot produce a "perfect" tree, nor is that our goal.
Indeed, we anticipate that there will almost always be tips in the tree that need correction, either because they get overlooked (`r eg`, placement of species within genera, which we did not have the resources to inspect) or because an updated taxonomic treatment is not yet available (`r eg`, cheilanthoid ferns).
One example of progressive refinement is Thelypteridaceae, which had the highest number of non-monophyletic genera (16) in the previous version of FTOL (v1.0.0).
After implementing a manual inclusion list for Thelypteridaceae and consulting with a taxonomic expert on this family (S. Fawcett), the number of non-monophyletic genera was reduced to `r top_nonmono_subfam %>% filter(family == "Thelypteridaceae") %>% pull(n)`.
While manual inclusion lists are not an ideal long-term solution because they cannot grow with GenBank, this case demonstrates that such lists are a reasonable option for taxonomically difficult groups, and more importantly, the improvement that can result from input from taxonomic experts.
Another example of the advantage of a continuously updated tree is the publication of 42 additional fern plastome samples while this paper was in revision [@Du2022].
While we were unable to integrate these data into the current version of FTOL, they will be automatically added when the next version of GenBank data is released, and we expect the next version of FTOL will reflect this new knowledge.

To facilitate community-driven improvements, we have made our methodology (code), data, and software (R packages and docker image) completely open and available.
It is our hope that other researchers using FTOL will contribute by making edits and suggestions, preferably through the GitHub repository (https://github.com/fernphy/ftol).
This way, FTOL will continually improve and keep pace with the currently available data and taxonomic hypotheses of ferns.

# Funding {-}
This study was supported by Japan Society for the Promotion of Science (Kakenhi) Grant numbers 16H06279, 22H04925, and 22K15171 and the Smithsonian National Museum of Natural History Peter Buck Fellowship (JHN).

# Acknowledgments {-}

The authors thank M. Hassler for maintaining the World Ferns taxonomic database and making it available to use for research.
Members of the Iwasaki lab provided comments that improved the manuscript.
A.E. White provided helpful comments on an early version of the analysis.
S. Fawcett provided helpful comments on taxonomy of Thelypteridaceae.

# References {-}
<!-- Insert <div id="refs"></div> to place the refs here instead of at the end -->
<div id="refs"></div>

`r pagebreak_pdf(params)`

# Figures {-}

```{r plot-prep}
### plot-prep start

# Make vector of outgroup taxa
og_taxa <-
  sanger_sampling %>%
  filter(outgroup == TRUE) %>%
  pull(species)

# Make tibble of backbone tips with higher-level taxonomy
backbone_taxonomy <-
  plastome_tree_rooted %>%
  ladderize() %>%
  get_tips_in_ape_plot_order() %>%
  tibble(species = .) %>%
  # Add higher taxonomy
  left_join(sanger_sampling, by = "species") %>%
  # Add column for phylogenetic order
  mutate(phy_order = seq_len(nrow(.))) %>%
  # Outgroup lacks family data, so call "og"
  mutate(
    family = case_when(
      outgroup == TRUE ~ "og",
      TRUE ~ family),
    major_clade = case_when(
      outgroup == TRUE ~ "og",
      TRUE ~ major_clade)
  )

# Make exemplar set of species in backbone representing plot groups
major_clade_exemp_taxa <-
  backbone_taxonomy %>%
  # Slice to one exemplar species per major clade
  group_by(major_clade) %>%
  slice(1) %>%
  ungroup() %>%
  # Slicing arranges alphabetically, so put back in (unladderized) phylo order
  arrange(phy_order) %>%
  # Drop outgroup
  filter(family != "og")

# Make a color palette for major clades
# Start with list of green.armytage.colors names,
# exclude those that are too close or stand out too much
# https://www.jstatsoft.org/article/view/v090c01
green_army_use_cols <-
  c(
    "amethyst",
    "blue",
    "caramel",
    "damson",
    # "ebony",
    # "forest",
    "green",
    "honeydew",
    # "iron",
    # "jade",
    # "khaki",
    # "lime",
    "mallow",
    "navy",
    # "orpiment",
    "pink",
    # "quagmire",
    "red",
    "sky",
    "turquoise",
    "uranium",
    "violet",
    "wine",
    # "xanthin",
    # "yellow",
    "zinnia"
  )

clade_cols <-
  Polychrome::green.armytage.colors() %>%
  extract(green_army_use_cols) %>%
  extract(seq_len(nrow(major_clade_exemp_taxa))) %>%
  set_names(major_clade_exemp_taxa$major_clade)

clade_cols_tib <-
  tibble(
    color = clade_cols,
    major_clade = names(clade_cols)
  ) %>%
  mutate(
    code = substr(major_clade, 1, 2),
    code = case_when(
      major_clade == "Saccolomatineae" ~ "Sac",
      major_clade == "Salviniales" ~ "Sal",
      TRUE ~ code
    )) %>%
  assert(is_uniq, code)

# Make tibble for annotating major clades
clade_tibble <-
  # Use assess_monophy to get MRCA of each major clade
  # They should all by monophyletic anyways
  select(sanger_sampling, species, major_clade) %>%
  assess_monophy(
    taxon_sampling = .,
    tree = sanger_tree_dated,
    tax_levels = "major_clade"
  ) %>%
  get_result_monophy(1) %>%
  # Exclude lycophytes
  filter(!taxon %in% c(
    "Selaginellales", "Lycopodiales", "Isoëtales", "Isoetales")) %>%
  verify(all(monophyly == "Yes")) %>%
  transmute(major_clade = taxon, mrca = parse_number(mrca)) %>%
  left_join(clade_cols_tib, by = "major_clade")

### Prep for stem family age plots ###

# Helper function for subsetting dates to get into
# almost-long format
subset_ages <- function(other_dates, author_sel) {
  other_dates %>%
    select(family, contains(glue("{author_sel}_"))) %>%
    rename_with(~str_remove_all(., glue("{author_sel}_"))) %>%
    mutate(author = author_sel)
}

# Define shapes and colors for points for stem family age plots
ages_shapes <- c(
  current = 16, # circle
  rothfels = 17, # triangle
  schuettpelz = 15, # square
  ts = 18 # diamond
)

ages_colors <- c(
  current = palette_okabe_ito(order = "vermillion"),
  rothfels = palette_okabe_ito(order = "bluishgreen"),
  schuettpelz = palette_okabe_ito(order = "blue"),
  ts = palette_okabe_ito(order = "orange")
)

# Format names of papers for printing for stem family age plots
ages_sampling <-
  tribble(
    ~source, ~year, ~label,
    "schuettpelz", 2009, "Schuettpelz and Pryer 2009",
    "rothfels", 2015, "Rothfels et al. 2015",
    "ts", 2016, "Testo and Sundue 2016",
    "current", 2021, "This study",
  ) %>%
  mutate(source = fct_reorder(source, year))


# Provide names of periods in captions
# Make sure to read and check that they are all there!
period_names <-
  periods %>%
  # Filter to range including Ordovician to Neogene
  filter(min_age < 475) %>%
  filter(min_age > 1) %>%
  arrange(desc(min_age)) %>%
  mutate(label = glue("{abbr} ({name})")) %>%
  pull(label) %>%
  paste(collapse = ", ")

### plot-prep end
```

```{r genbank-make}
fern_tree_sampling <-
  tribble(
    ~source, ~year, ~n_species, ~label,
    "Hasebe1995", 1995, 107, "Hasebe et al. 1995",
    "Schuettpelz2007", 2007, 400, "Schuettpelz and Pryer 2007",
    "Lehtonen2011", 2011, 2957, "Lehtonen 2011",
    "Testo2016a", 2016, 3973, "Testo and Sundue 2016",
    "this_study", 2021, n_sanger_ferns, "This study",
  ) %>%
  mutate(source = fct_reorder(source, year))

compartment_labs <- 
  gb_species_by_year %>%
  filter(year == max(year)) %>%
  transmute(
    type,
    label = str_to_sentence(type),
    year,
    n_species
  )

okabe_ito_cols <-
  palette_okabe_ito(1:9) %>%
  set_names(
    c("orange", "light_blue", "green", 
      "yellow", "blue", "red",
      "magenta", "grey", "black"))

compartment_cols <- c(
  mitochondrial = okabe_ito_cols["red"] %>% set_names(NULL),
  nuclear = okabe_ito_cols["blue"] %>% set_names(NULL),
  plastid = okabe_ito_cols["green"] %>% set_names(NULL),
  total = "grey40"
)

# Manually specify axis buffers since we will annotate the panel border manually
year_buffer <- 
  max(gb_species_by_year$year) %>%
  subtract(min(gb_species_by_year$year)) %>%
  multiply_by(0.05)
sp_buffer <- max(gb_species_by_year$n_species) %>%
  subtract(min(gb_species_by_year$n_species)) %>%
  multiply_by(0.05)

genbank_plot <-
  ggplot(gb_species_by_year, aes(x = year, y = n_species)) +
  geom_line(aes(color = type)) +
  scale_color_manual(values = compartment_cols, guide = "none") +
  # Annotate panel border manually, since the automatic border gets
  # printed on top of label annotations with theme_bw()
  annotate(
    "rect", 
    xmin = min(gb_species_by_year$year) - year_buffer,
    xmax = max(gb_species_by_year$year) + year_buffer,
    ymin = min(gb_species_by_year$n_species) - sp_buffer,
    ymax = max(gb_species_by_year$n_species) + sp_buffer,
    fill = "transparent",
    color = "grey20") +
  geom_label_repel(
    data = compartment_labs %>% filter(type %in% c("nuclear", "mitochondrial")),
    aes(color = type, label = label),
    segment.linetype = 2, 
    xlim = c(2020, Inf),
    # Do not repel from top or bottom edges.
    ylim = c(-Inf, Inf)
  ) +
  geom_label_repel(
    data = compartment_labs %>% filter(type %in% c("total", "plastid")),
    aes(color = type, label = label),
    segment.linetype = 2, 
    xlim = c(2020, Inf),
    ylim = c(-Inf, Inf),
    min.segment.length = 0
  ) +
  geom_point(
    data = fern_tree_sampling,
    aes(shape = source)
  ) +
  scale_shape(
    limits = fern_tree_sampling$source, 
    labels = fern_tree_sampling$label
  ) +
  scale_x_continuous(expand = expansion(0, 0)) + 
  scale_y_continuous(expand = expansion(0, 0)) + 
  labs(shape = "Study", y = "No. species", x = "Year") +
  coord_cartesian(clip = "off") +
  guides(shape = guide_legend(nrow = 2)) +
  theme_bw() +
  theme(
    panel.border = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank(),
    plot.margin = margin(r = 1, t = 0.5, l = 0.5, unit = "in")
  )
```

```{r genbank-save, eval = params$doc_type == "doc" }
# Save plot if rendering to doc
ggsave(
  result_file(figure("genbank"), "tiff"),
  genbank_plot, width = 7, height = 5, units = "in")
```

```{r genbank-print, fig.width = 7, fig.height = 5, eval = params$doc_type == "pdf"}
# Print plot if rendering to PDF
genbank_plot
```

**`r figure("genbank")`**.
Number of fern species in GenBank by year and genomic compartment, 1990--2021.
Points indicate number of species sampled in selected studies of global fern phylogeny [@Hasebe1995; @Schuettpelz2007; @Lehtonen2011; @Testo2016a\; this study].
This study plotted as 2021 but includes data until 2022-04-15.
@Schuettpelz2007 did not attempt exhaustive sampling but rather proportional sampling according to lineage size.
The relatively small increase in number of species in 2021 may be due to accessions that were still embargoed at the time of writing.
Taxonomy of GenBank species follows NCBI [@Federhen2012].
Only accessions identified to species included; environmental samples, hybrid formulas, and names with "aff." or "cf." annotations excluded.

`r pagebreak_pdf(params)`

```{r workflow-save, eval = params$doc_type == "doc" }
# Convert workflow image to tiff for submission
pdftools::pdf_convert(
  pdf = here::here("images/workflow.pdf"),
  filenames = result_file(figure("workflow"), "tiff"),
  format = "tiff",
  dpi = 300)
```

```{r workflow-print, fig.width = 7, fig.height = 5, eval = params$doc_type == "pdf", results = "show"}
# Print plot if rendering to PDF
knitr::include_graphics(here::here("images/workflow.pdf"))
```

**`r figure("workflow")`**.
Summary of workflow to construct the Fern Tree of Life (FTOL).
The workflow is automated except for steps in boxes with red outlines and a hand symbol.
Numbers of sequences and species are approximate.
Sequences originating from whole plastomes are in blue; sequences typically obtained by Sanger sequencing are in orange.
For details of each step, see Materials and Methods.

`r pagebreak_pdf(params)`

```{r ftol-make}
# Coverage bar plot ----

# Make tibble of backbone tips with higher-level taxonomy
sanger_clade_exemp_taxa <-
  sanger_tree_dated %>%
  ladderize() %>%
  get_tips_in_ape_plot_order() %>%
  tibble(species = .) %>%
  # Add higher taxonomy
  left_join(sanger_sampling, by = "species") %>%
  # Add column for phylogenetic order
  mutate(phy_order = seq_len(nrow(.))) %>%
  # Outgroup lacks family data, so call "og"
  mutate(
    family = case_when(
      outgroup == TRUE ~ "og",
      TRUE ~ family),
    major_clade = case_when(
      outgroup == TRUE ~ "og",
      TRUE ~ major_clade)
  ) %>%
  # Make exemplar set of species in backbone representing plot groups
  # Slice to one exemplar species per major clade
  group_by(major_clade) %>%
  slice(1) %>%
  ungroup() %>%
  # Slicing arranges alphabetically, so put back in (unladderized) phylo order
  arrange(phy_order) %>%
  # Drop outgroup
  filter(family != "og")

# Format y-axis text: show major clade abbreviations in bold
clade_labs_tib <-
  clade_cols_tib %>%
  select(major_clade, code) %>%
  mutate(
    clade_short = map2_chr(major_clade, code, ~str_remove(.x, .y)),
    label = glue("**{code}**{clade_short}"))

clade_labs <- clade_labs_tib$label %>%
  set_names(., clade_labs_tib$major_clade)

# Format coverage at order-ish level for plotting
b <-
  coverage_by_rank %>%
  filter(rank == "major_clade") %>%
  left_join(sanger_clade_exemp_taxa, by = c(name = "major_clade")) %>%
  arrange(phy_order) %>%
  rename(clade = name) %>%
  mutate(
    clade = fct_reorder(clade, phy_order) %>%
      fct_rev(),
    coverage_text = glue("{number(n, accuracy = 1)}/{number(n_accepted, accuracy = 1)}")
  ) %>%
  ggplot(aes(x = coverage, y = clade, fill = clade)) +
  geom_col(color = "grey10", size = 0.2) +
  geom_text(
    aes(label = coverage_text),
    hjust = 0,
    nudge_x = 0.01,
    size = 6*.36 # 6 pt font
  ) +
  scale_x_continuous(
    labels = percent,
    limits = c(0,1),
    expand = expansion(mult = c(0, 0))
  ) +
  scale_fill_manual(values = clade_cols) +
  scale_y_discrete(labels = clade_labs) +
  labs(x = "Coverage") +
  theme_bw() +
  theme(
    axis.text.y = element_markdown(size = 6),
    axis.title.y = element_blank(),
    legend.position = "none",
    plot.background = element_rect(fill = "transparent", colour = NA),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.x = element_blank()
  )

# Tree plot ----

# Helper function to label clades with different offset
# For some reason, using the same offset.text around the plot
# results in different positions of text relative to bars. 
# Account for this by manual adjusting offset.text
ftol_geom_cladelab <- function(code_select, offset_text) {
  geom_cladelab(
    data = filter(clade_tibble, code %in% code_select),
    mapping = aes(
      node = mrca,
      color = major_clade,
      label = code
    ),
    offset = 0.1,
    offset.text = offset_text,
    fontsize = 2.5,
    textcolour = "black",
    barsize = 2)
}

a <- ggtree(
  sanger_tree_dated, 
    layout = "fan", right = FALSE, size = 0.1, open.angle = 2) + 
  ftol_geom_cladelab(
    clade_tibble$code[clade_tibble$code %in% c("Eq", "Op", "Ma", "Os", "Gl")], 10) +
  ftol_geom_cladelab(
    clade_tibble$code[clade_tibble$code %in% c("Hy", "Sc", "Sal")], 14) +
  ftol_geom_cladelab(
    clade_tibble$code[clade_tibble$code %in% c("Cy", "Sac", "Li")], 17) +
  ftol_geom_cladelab("De", 36) +
  ftol_geom_cladelab("Pt", 26) +
  ftol_geom_cladelab("As", 34) +
  ftol_geom_cladelab("Po", 17) +
  scale_color_manual(values = clade_cols) +
  geom_treescale(
    width = 100, # 100 Ma
    fontsize = 2, 
    y = 5600, # Just above "top" of tree
    label = "100 my", 
    offset = 1000, # hack to get default scale width (lacks units) to go away
    offset.label = -10) +
  theme(legend.position = "none")

# Assemble plots ----
ftol_plot <-
  a + inset_element(b, left = 0.85, bottom = 0.14, right = 1.3, top = .8) +
  plot_annotation(
    theme = theme(
      plot.margin = unit(c(-2,5,-2,-1.4), "cm"))
  )
```

```{r ftol-save, eval = params$doc_type == "doc"}
# Save plot if rendering to doc
ggsave(
  result_file(figure("ftol"), "pdf"),
  ftol_plot, width = 7, height = 7, units = "in")
```

```{r ftol-print, fig.width = 7, fig.height = 7, eval = params$doc_type == "pdf"}
# Print plot if rendering to PDF
ftol_plot
```

**`r figure("ftol")`**.
Fern Tree of Life (FTOL).
Tree rooted with algae.
Inset plot shows coverage by major clade (order or suborder).
Bold part of each clade name is its code, which is also indicated on the tree.
Numbers next to each bar show sampled species out of total number of species.
Taxonomy follows @PteridophytePhylogenyGroupI2016.

`r pagebreak_pdf(params)`

```{r backbone-make}
# Make exemplar set of species in backbone representing families
family_exemp <-
  backbone_taxonomy %>%
  # Drop outgroups %>%
  filter(family != "og") %>%
  # Slice to one exemplar species per family
  group_by(family) %>%
  slice(1) %>%
  ungroup() %>%
  # Slicing arranges alphabetically, so put back in (unladderized) phylo order
  arrange(phy_order)

# Trim tree to exemplar species, rename by family
phy <- keep.tip(plastome_tree_rooted, family_exemp$species)
new_tip_label <-
  tibble(species = phy$tip.label) %>%
  left_join(family_exemp, by = "species") %>%
  pull(family)
phy$tip.label <- new_tip_label
# Convert BS support values to numeric
# phy$node.label <- parse_number(phy$node.label)
# Scale to total height of 100 for easy plotting
phy <- rescale_tree(phy, 100)

# Make tibble for printing BS values
bs_tibble <- make_bs_tbl(phy) %>%
  # only print values < 100
  mutate(bs = case_when(
    bs == 100 ~ "",
    TRUE ~ as.character(bs)
  ))

# Make tibble for labeling clades
phy_tip <- as_tibble(phy)

suborder_labels_singletons <-
  family_exemp %>% 
  filter(outgroup == FALSE) %>%
  group_by(major_clade) %>%
  select(major_clade, family) %>% 
  filter(n_distinct(family) == 1) %>%
  ungroup() %>%
  left_join(phy_tip, by = c(family = "label")) %>%
  select(major_clade, mrca = node)

suborder_labels <-
  family_exemp %>% 
  filter(outgroup == FALSE) %>%
  group_by(major_clade) %>%
  select(major_clade, family) %>% 
  filter(n_distinct(family) > 1) %>%
  summarize(taxa = list(family)) %>%
  mutate(
    mrca = map_chr(taxa, ~getMRCA(phy, .))
  ) %>%
  transmute(
    major_clade,
    mrca
  ) %>%
  mutate(mrca = parse_number(mrca)) %>%
  bind_rows(suborder_labels_singletons) %>%
  mutate(
    clade_label = case_when(
      major_clade == "Aspleniineae" ~ "Aspleniineae\n(eupolypods II)",
      major_clade == "Polypodiineae" ~ "Polypodiineae\n(eupolypods I)",
      TRUE ~ major_clade
    )
  )

# Get data of x and y co-ordinates for ggtree plot
phy_plot_data <- ggplot_build(ggtree(phy)) %>%
  magrittr::extract2("data") %>%
  magrittr::extract2(1) %>%
  as_tibble()

# Make a dataframe for plotting various clade labels
other_clade_labels <-
  list(
    "eupolypods" = c("Polypodiaceae", "Aspleniaceae"),
    "Polypodiales" = c("Polypodiaceae", "Saccolomataceae"),
    "Polypodiidae\n(leptosporangiates)" = c("Polypodiaceae", "Osmundaceae")
  ) %>%
  tibble(
    clade_label = names(.),
    x = map_dbl(., ~node_height_from_tips(phy, .)),
    node = map_dbl(., ~ape::getMRCA(phy, .))
  ) %>%
  left_join(
    select(phy_plot_data, node, y), by = "node"
  ) %>%
  select(-`.`, -node)

segment_cols <-
  rep("grey20", length(other_clade_labels$clade_label)) %>%
  set_names(other_clade_labels$clade_label)

set.seed(123)
# Use the ggtree::`%<+%` operator to map the
# bootstrap values onto the ggtree object
bump <- 5 # for easier fiddling of plot size
backbone_plot <-
  ggtree(phy) %<+% bs_tibble  +
  theme(legend.position = "none") +
  # now we can show BS values using geom_text()
  geom_text(aes(label = bs), hjust = -.25, size = 2.5) +
  # add tip labels
  geom_tiplab(aes(label = label)) +
  # highlight major clades
  geom_hilight(
    data = suborder_labels,
    mapping = aes(
      node = mrca,
      fill = major_clade
    ),
    alpha = 0.2,
    align = "right",
    extend = 36 + bump,
    gradient.direction = "rt",
    roundrect = TRUE,
    gradient.length.out = 2) +
  scale_fill_manual(values = clade_cols) +
  xlim(0, 190 + bump) +
  # label major clades
  geom_cladelab(
    data = suborder_labels,
    mapping = aes(
      node = mrca,
      label = clade_label
    ),
    offset = 34 + bump,
    align = TRUE,
    extend = 0.3,
    hjust = 0,
    barcolour = "grey20",
    barsize = 2) +
  # Label other groups
  geom_text_repel(
    data = other_clade_labels %>%
      filter(clade_label == "Polypodiidae\n(leptosporangiates)"),
    aes(x = x, y = y, label = clade_label),
    hjust = 0,
    xlim = c(NA, 10),
    ylim = c(15, NA),
    color = "grey20",
    segment.color = "grey20"
  ) +
  geom_text_repel(
    data = other_clade_labels %>%
      filter(clade_label == "eupolypods"),
    aes(x = x, y = y, label = clade_label),
    hjust = 0,
    xlim = c(NA, 52),
    ylim = c(32, NA),
    color = "grey20",
    segment.color = "grey20"
  ) +
  geom_text_repel(
    data = other_clade_labels %>%
      filter(clade_label == "Polypodiales"),
    aes(x = x, y = y, label = clade_label),
    hjust = 0,
    xlim = c(NA, 48),
    ylim = c(24, NA),
    color = "grey20",
    segment.color = "grey20"
  ) +
  coord_cartesian(clip = "off")
```

```{r backbone-tree-save, eval = params$doc_type == "doc"}
# Save plot if rendering to doc
ggsave(
  result_file(figure("backbone"), "tiff"),
  backbone_plot, width = 7, height = 9, units = "in")
```

```{r backbone-tree-print, fig.width = 7, fig.height = 9, eval = params$doc_type == "pdf"}
# Print plot if rendering to PDF
backbone_plot
```

**`r figure("backbone")`**.
Fern tree of life (FTOL) backbone phylogeny.
One exemplar tip is shown per family (all families were found to be monophyletic; see Results).
Ultrafast bootstrap support values (%) shown at nodes; unlabeled nodes are 100%.
Outgroup (seed plants, lycophytes, bryophytes, and algae) not shown.
Colors of major clades (orders or suborders) correspond to those used in `r figure("ftol")`. Taxonomy follows @PteridophytePhylogenyGroupI2016; informal clade names in lowercase.

`r pagebreak_pdf(params)`

```{r div-times-make}
# Combine family stem ages into almost-long format:
# one row per family/study combination,
# cols for median, high, and low date
all_family_stem_ages <-
  bind_rows(
    subset_ages(other_dates, "ts"),
    subset_ages(other_dates, "rothfels"),
    select(other_dates, family, median = schuettpelz_best) %>%
      mutate(author = "schuettpelz"),
    transmute(
      family_stem_ages,
      family,
      author = "current",
      median = age
    )
  ) %>%
  left_join(
    unique(select(sanger_sampling, family, major_clade)), by = "family") %>%
  left_join(clade_tibble, by = "major_clade") %>%
  # (some median dates are NA if that family wasn't included in a study)
  assert(not_na, family, major_clade, code, author) %>%
  # Set family as a factor ordered by current age estimate
  left_join(family_stem_ages, by = "family") %>%
  mutate(family = fct_reorder(family, age)) %>%
  select(-age)

# Format y-axis text: show major clade in parentheses
family_labs_tbl <-
  all_family_stem_ages %>%
  select(family, code) %>%
  unique() %>%
  mutate(label = glue("{family} ({code})"))

family_labs <- family_labs_tbl$label %>%
  set_names(., family_labs_tbl$family)

# Make plot
div_times_plot <-
  ggplot(all_family_stem_ages) +
  geom_pointrange(
    aes(
      x = median, xmin = low, xmax = high,
      y = family,
      color = author, shape = author),
    position = position_dodge(width = 0.5)) +
  scale_shape_manual(
    values = ages_shapes,
    limits = ages_sampling$source, 
    labels = ages_sampling$label) +
  scale_color_manual(
    values = ages_colors,
    limits = ages_sampling$source, 
    labels = ages_sampling$label) +
  scale_y_discrete(labels = family_labs, expand = expansion(add = 0.7)) +
  scale_x_reverse("Age (millions of years)", expand = c(0,0)) +
  coord_geo(
    dat = list("periods", "eras"),
    pos = list("b", "b"),
    abbrv = list(TRUE, FALSE),
    xlim = c(500, 0),
    fill = "transparent",
    color = "grey20",
    lab_color = "grey30",
    height = unit(1, "lines"),
    expand = TRUE,
    size = 3) +
  guides(shape = guide_legend(nrow = 2)) +
  theme_bw() +
  theme(
    axis.title.y = element_blank(),
    legend.title = element_blank(),
    legend.position = "bottom"
  )
```

```{r div-times-save, eval = params$doc_type == "doc"}
# Save plot if rendering to doc
ggsave(
  result_file(figure("divtimes"), "tiff"),
  div_times_plot, width = 7, height = 8, units = "in")
```

```{r div-times-print, fig.width = 7, fig.height = 9, eval = params$doc_type == "pdf"}
# Print plot if rendering to PDF
div_times_plot
```

**`r figure("divtimes")`**.
Stem age of fern families (Ma) estimated by selected studies.
For studies that used methods with confidence intervals, error bars indicate lower and upper 95% highest posterior density levels and point indicates median [@Rothfels2015a; @Testo2016a].
For other studies, point indicates best (most likely) estimate [@Schuettpelz2009\; this study].
Codes in parentheses after family names indicate major clade as in `r figure("ftol")`.
Period name abbreviations as follows: `r period_names`.